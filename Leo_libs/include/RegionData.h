#ifndef REGIONDATA_H_
#define REGIONDATA_H_

#include <iostream>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <utility>
#include <cstddef>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <fstream>
#include <boost/filesystem.hpp>

using namespace std;
namespace fs = boost::filesystem;

class RegionData 
{

public:
    // Member functions
    RegionData() :
        ori_image(),ori_map(),image(), map(), xRes(1.0), yRes(1.0),
        transform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)),
        invertTransform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)),
        hasRotated(false), topLeftWorldLatitude(INVALID_DEGREE_VALUE),
        topLeftWorldLongitude(INVALID_DEGREE_VALUE) {};

    // This function loads the raw world image (i.e. Satellite view), the
    // binary world map (i.e. for computing the BCD), and auxiliary GCS
    // information
    //
    // E.g.: loadWorld("./image.png") assumes the following files exist:
    // - "./image.png": raw world image
    // - "./image.map.png": binary world map
    // - "./image.wf": world file, generated by Procerus MapMaker
    void loadWorld(std::string filename) throw (const std::string&);

    // Loads latitude and longitude data from .wf file
    void parseWorldFile(std::string filename) throw (const std::string&);

    bool empty();

    cv::Mat rotateImage(const cv::Mat& source, double angle,
            cv::Point2f src_center);

    cv::Mat rotateImage(const cv::Mat& source, const cv::Mat& newTransform,
            double width, double height);

    std::pair<double, cv::Point2f> computeAlignmentToObstacles();

    std::pair<double, cv::Point2f> computeAlignmentToFreespace();

    // Utility macro to rotate both the world and the map
    // NOTE: angle is in degrees, IN RIGHT HAND COORD SYSTEM!!!
    inline void rotateAllData(double angle, cv::Point2f src_center);
    inline void rotateAllData(double angle);
    inline void rotateAllData(std::pair<double, cv::Point2f> angle_ctr);
    inline void rotateAllData(const cv::Mat& newTransform, double width,
            double height);

    std::pair<double, double> transformPoint(double xPixel, double yPixel);
    std::pair<double, double> invertTransformPoint(double xPixel, double yPixel);

    // Same as transformPoint, except does not shift by offsets
    std::pair<double, double> rotateVector(double xPixel, double yPixel);
    std::pair<double, double> invertRotateVector(double xPixel, double yPixel);

    // Static functions
    static bool solveQuadraticEquation(double A, double B, double C,
            double &r1, double &r2);

    void clear();

    cv::Mat getImage();
    cv::Mat getMap();
    cv::Mat getOriginalImage();
    cv::Mat getOriginalMap();

    // Member fields
    cv::Mat ori_image;
    cv::Mat ori_map;
    cv::Mat image; // raw world image
    cv::Mat map; // black = obstacle, white = free space
    double xRes; // units: meter / pixel
    double yRes; // units: meter / pixel
    cv::Mat transform;
    cv::Mat invertTransform; // to get the original pixel location, use this.
    bool hasRotated;
    std::string loadWorldFilename;

    // Constants
    const static unsigned char BLACK = 0;
    const static unsigned char WHITE = 255;

    double topLeftWorldLatitude;
    double topLeftWorldLongitude;

    //const static float INVALID_DEGREE_VALUE = 361.0;
    static constexpr float INVALID_DEGREE_VALUE = 361.0;
};


#endif /* REGIONDATA_H_ */
